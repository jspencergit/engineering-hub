<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Impedance Matching - Analog Engineering Hub</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            text-align: center;
            padding: 10px;
            background-color: #1a73e8;
            color: white;
        }
        section {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: white;
            padding: 20px;
        }
        .chart-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        .smith-chart {
            width: 80vh;
            height: 80vh;
            max-width: 1000px;
            max-height: 1000px;
            flex-shrink: 0;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
        }
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 250px;
            flex-shrink: 0;
        }
        #mouseImpedance, #matchingSolution {
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        .coordinates {
            max-height: 40vh; /* Adjusted for new controls */
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .coordinates div {
            margin: 5px 0;
            white-space: nowrap;
            font-size: 12px;
        }
        .coordinates .dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        button {
            background-color: #1a73e8;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #1557b0;
        }
        .impedance-input, .reflection-control, .frequency-control {
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .impedance-input label, .reflection-control label, .frequency-control label {
            font-size: 14px;
        }
        .impedance-input input, .reflection-control input[type="number"], .frequency-control input[type="number"] {
            width: 80px;
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .impedance-input button {
            padding: 8px;
            font-size: 14px;
        }
        .reflection-control input[type="range"], .frequency-control input[type="range"] {
            width: 100%;
        }
        .reflection-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .frequency-control select {
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Analog Engineering Hub</h1>
        <p><a href="https://jspencergit.github.io/engineering-hub/tools.html">Back to Tools</a></p>
    </header>

    <section id="tools">
        <div class="chart-container">
            <div class="smith-chart">
                <canvas id="smithChart" width="800" height="800"></canvas>
            </div>
            <div class="right-panel">
                <div class="impedance-input">
                    <h3>Start Impedance</h3>
                    <label>Real (Ω): <input type="number" id="realImpedance" value="50" step="any"></label>
                    <label>Imaginary (Ω): <input type="number" id="imagImpedance" value="0" step="any"></label>
                    <button onclick="placeMarker()">Place Marker</button>
                </div>
                <div class="impedance-input">
                    <h3>Target Impedance</h3>
                    <label>Real (Ω): <input type="number" id="targetRealImpedance" value="50" step="any"></label>
                    <label>Imaginary (Ω): <input type="number" id="targetImagImpedance" value="0" step="any"></label>
                    <button onclick="placeTarget()">Place Target</button>
                </div>
                <div class="reflection-control">
                    <label><input type="checkbox" id="showReflectionCircles" onchange="toggleReflectionCircles()"> Show Reflection Circles</label>
                    <div class="reflection-inputs">
                        <label>|Γ|: <input type="number" id="reflectionValue" value="0.5" min="0" max="1" step="0.01" oninput="updateReflectionFromMagnitude()"></label>
                        <label>Return Loss (dB): <input type="number" id="returnLossValue" value="-6" min="-100" max="0" step="0.1" oninput="updateReflectionFromReturnLoss()"></label>
                    </div>
                    <input type="range" id="reflectionSlider" value="0.5" min="0" max="1" step="0.01" oninput="updateReflectionFromSlider()">
                </div>
                <div class="frequency-control">
                    <label>Frequency: <input type="number" id="frequencyValue" value="1" min="1" step="1" oninput="updateFrequencyFromInput()"></label>
                    <select id="frequencyUnit" onchange="updateFrequencyFromUnit()">
                        <option value="Hz">Hz</option>
                        <option value="kHz">kHz</option>
                        <option value="MHz" selected>MHz</option>
                        <option value="GHz">GHz</option>
                    </select>
                    <input type="range" id="frequencySlider" value="6" min="0" max="10" step="0.1" oninput="updateFrequencyFromSlider()">
                </div>
                <div id="mouseImpedance">Move mouse over chart</div>
                <div id="matchingSolution">Matching solution will appear here</div>
                <div class="coordinates" id="coordinates"></div>
            </div>
        </div>
        <button onclick="clearDots()">Clear Dots</button>
    </section>

    <script>
        const smithCtx = document.getElementById("smithChart").getContext("2d");
        const coordinatesDiv = document.getElementById("coordinates");
        const mouseImpedanceDiv = document.getElementById("mouseImpedance");
        const matchingSolutionDiv = document.getElementById("matchingSolution");
        const realImpedanceInput = document.getElementById("realImpedance");
        const imagImpedanceInput = document.getElementById("imagImpedance");
        const targetRealImpedanceInput = document.getElementById("targetRealImpedance");
        const targetImagImpedanceInput = document.getElementById("targetImagImpedance");
        const showReflectionCirclesCheckbox = document.getElementById("showReflectionCircles");
        const reflectionValueInput = document.getElementById("reflectionValue");
        const returnLossValueInput = document.getElementById("returnLossValue");
        const reflectionSlider = document.getElementById("reflectionSlider");
        const frequencyValueInput = document.getElementById("frequencyValue");
        const frequencyUnitSelect = document.getElementById("frequencyUnit");
        const frequencySlider = document.getElementById("frequencySlider");
        let smithChart;
        let dots = [];
        const colors = ["#FF5733", "#33FF57", "#3357FF", "#FF33A1", "#FFD700", "#8A2BE2", "#00CED1"];
        let lastMouseX = null;
        let lastMouseY = null;

        function calculateImpedance(x, y) {
            const Z0 = 50;
            const gammaReal = x;
            const gammaImag = y;
            const denom = 1 - gammaReal + (gammaImag * gammaImag) / (1 - gammaReal);
            const R = Z0 * ((1 - gammaReal * gammaReal - gammaImag * gammaImag) / denom);
            const X = Z0 * (2 * gammaImag / denom);
            return { impedance: `Z = ${R.toFixed(1)} + j${X.toFixed(1)} Ω`, R: R, X: X };
        }

        function impedanceToGamma(R, X) {
            const Z0 = 50;
            const Z = math.complex(R, X);
            const gamma = math.divide(math.subtract(Z, Z0), math.add(Z, Z0));
            return { x: gamma.re, y: gamma.im };
        }

        function generateReflectionCircle(magnitude) {
            const data = [];
            for (let theta = 0; theta <= 2 * Math.PI; theta += 0.05) {
                const x = magnitude * Math.cos(theta);
                const y = magnitude * Math.sin(theta);
                data.push({ x: x, y: y });
            }
            return data;
        }

        function gammaToReturnLoss(gamma) {
            return -20 * Math.log10(gamma);
        }

        function returnLossToGamma(returnLoss) {
            return Math.pow(10, returnLoss / 20);
        }

        function calculateMatchingNetwork(startZ, targetZ, freqHz) {
            const Z0 = 50;
            const omega = 2 * Math.PI * freqHz;
            const startReal = startZ.R, startImag = startZ.X;
            const targetReal = targetZ.R, targetImag = targetZ.X;

            // Simple L-network (series then shunt to ground)
            let seriesX, shuntX;
            if (startReal < targetReal) {
                // Series inductor, shunt capacitor
                seriesX = Math.sqrt(targetReal * (Z0 - startReal)) - startImag;
                shuntX = -targetReal * (startImag + seriesX) / (targetReal - startReal);
            } else {
                // Series capacitor, shunt inductor
                seriesX = -Math.sqrt(targetReal * (startReal - Z0)) - startImag;
                shuntX = targetReal * (startImag + seriesX) / (startReal - targetReal);
            }

            let seriesComponent = seriesX > 0 ? `L: ${(seriesX / omega * 1e9).toFixed(2)} nH` : `C: ${(-1 / (seriesX * omega) * 1e12).toFixed(2)} pF`;
            let shuntComponent = shuntX > 0 ? `L: ${(shuntX / omega * 1e9).toFixed(2)} nH` : `C: ${(-1 / (shuntX * omega) * 1e12).toFixed(2)} pF`;

            return { series: seriesComponent, shunt: shuntComponent };
        }

        function generateMatchingPath(startGamma, targetGamma) {
            const path = [];
            const steps = 50;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = startGamma.x + (targetGamma.x - startGamma.x) * t;
                const y = startGamma.y + (targetGamma.y - startGamma.y) * t;
                path.push({ x: x, y: y });
            }
            return path;
        }

        try {
            smithChart = new Chart(smithCtx, {
                type: "scatter",
                data: {
                    datasets: [
                        { label: "Outer Circle", data: [], borderColor: "#333", borderWidth: 2, pointRadius: 0, showLine: true, fill: false },
                        { label: "r=0", data: [], borderColor: "#0000FF", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "r=0.5", data: [], borderColor: "#0000FF", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "r=1", data: [], borderColor: "#0000FF", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "r=2", data: [], borderColor: "#0000FF", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=0", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=0.5", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=-0.5", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=1", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=-1", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=2", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "x=-2", data: [], borderColor: "#097969", borderWidth: 1, pointRadius: 0, showLine: true, fill: false },
                        { label: "Dots", data: [], pointRadius: 5, pointStyle: "circle", borderWidth: 0, showLine: false, backgroundColor: [] },
                        { label: "Marker", data: [], pointRadius: 10, pointStyle: "circle", backgroundColor: "#d3d3d3", borderColor: "#000000", borderWidth: 2, showLine: false },
                        { label: "Reflection Circle", data: [], borderColor: "#FF0000", borderWidth: 1, pointRadius: 0, showLine: true, fill: false, hidden: true },
                        { label: "Target", data: [], pointRadius: 10, pointStyle: "circle", backgroundColor: "#0000FF", borderColor: "#000000", borderWidth: 2, showLine: false },
                        { label: "Matching Path", data: [], borderColor: "#00FF00", borderWidth: 2, borderDash: [5, 5], pointRadius: 0, showLine: true, fill: false }
                    ]
                },
                options: {
                    scales: {
                        x: { min: -1, max: 1, display: false },
                        y: { min: -1, max: 1, display: false }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    aspectRatio: 1,
                    maintainAspectRatio: true,
                    responsive: false,
                    events: ['mousemove', 'click'],
                    hover: { mode: null },
                    onClick: function(event, elements, chart) {
                        if (lastMouseX !== null && lastMouseY !== null) {
                            const mag = Math.sqrt(lastMouseX * lastMouseX + lastMouseY * lastMouseY);
                            if (mag <= 1) {
                                const color = colors[dots.length % colors.length];
                                const { impedance, R, X } = calculateImpedance(lastMouseX, lastMouseY);
                                dots.push({ x: lastMouseX, y: lastMouseY, color: color, R: R, X: X });
                                console.log(`Clicked at: x=${lastMouseX.toFixed(2)}, y=${lastMouseY.toFixed(2)}, ${impedance}`);
                                updateDots();
                            }
                        }
                    }
                }
            });
            console.log("Chart initialized successfully");
        } catch (error) {
            console.error("Error initializing chart:", error);
        }

        function generateSmithChart() {
            try {
                let outerData = [];
                for (let theta = 0; theta <= 2 * Math.PI; theta += 0.05) {
                    let x = Math.cos(theta);
                    let y = Math.sin(theta);
                    outerData.push({ x: x, y: y });
                }
                smithChart.data.datasets[0].data = outerData;

                const rValues = [0, 0.5, 1, 2];
                rValues.forEach((r, index) => {
                    let data = [];
                    const centerX = r / (1 + r);
                    const radius = 1 / (1 + r);
                    for (let theta = 0; theta <= 2 * Math.PI; theta += 0.05) {
                        let x = centerX + radius * Math.cos(theta);
                        let y = radius * Math.sin(theta);
                        data.push({ x: x, y: y });
                    }
                    smithChart.data.datasets[index + 1].data = data;
                });

                const xValues = [0, 0.5, -0.5, 1, -1, 2, -2];
                xValues.forEach((x, index) => {
                    let data = [];
                    if (x === 0) {
                        for (let xCoord = -1; xCoord <= 1; xCoord += 0.05) {
                            data.push({ x: xCoord, y: 0 });
                        }
                    } else {
                        const centerX = 1;
                        const centerY = 1 / x;
                        const radius = Math.abs(1 / x);
                        for (let theta = 0; theta <= 2 * Math.PI; theta += 0.05) {
                            let xCoord = centerX + radius * Math.cos(theta);
                            let yCoord = centerY + radius * Math.sin(theta);
                            let mag = Math.sqrt(xCoord * xCoord + yCoord * yCoord);
                            if (mag <= 1 + 0.01) {
                                if (x > 0 && yCoord >= 0) {
                                    data.push({ x: xCoord, y: yCoord });
                                } else if (x < 0 && yCoord <= 0) {
                                    data.push({ x: xCoord, y: yCoord });
                                }
                            }
                        }
                    }
                    smithChart.data.datasets[index + 5].data = data;
                });

                smithChart.data.datasets[14].data = generateReflectionCircle(0.5);
                smithChart.update();
                console.log("Chart updated successfully");
            } catch (error) {
                console.error("Error generating Smith Chart:", error);
            }
        }

        function updateDots() {
            const dotDataset = smithChart.data.datasets[12];
            dotDataset.data = dots.map(dot => ({ x: dot.x, y: dot.y }));
            dotDataset.backgroundColor = dots.map(dot => dot.color);
            coordinatesDiv.innerHTML = dots.map((dot, i) => `
                <div>
                    <span class="dot" style="background-color: ${dot.color};"></span>
                    Dot ${i + 1}: Z = ${dot.R.toFixed(1)} + j${dot.X.toFixed(1)} Ω
                </div>
            `).join('');
            smithChart.update();
        }

        function clearDots() {
            dots = [];
            smithChart.data.datasets[13].data = [];
            smithChart.data.datasets[15].data = [];
            smithChart.data.datasets[16].data = [];
            mouseImpedanceDiv.textContent = "Move mouse over chart";
            matchingSolutionDiv.textContent = "Matching solution will appear here";
            updateDots();
        }

        function placeMarker() {
            const R = parseFloat(realImpedanceInput.value);
            const X = parseFloat(imagImpedanceInput.value);
            if (isNaN(R) || isNaN(X)) {
                alert("Please enter valid real and imaginary impedance values.");
                return;
            }
            const { x, y } = impedanceToGamma(R, X);
            const mag = Math.sqrt(x * x + y * y);
            if (mag <= 1) {
                smithChart.data.datasets[13].data = [{ x: x, y: y }];
                updateMatchingSolution();
                smithChart.update();
                console.log(`Marker placed at: x=${x.toFixed(2)}, y=${y.toFixed(2)}, Z=${R.toFixed(1)}+j${X.toFixed(1)}`);
            } else {
                alert("Impedance results in a reflection coefficient outside the Smith Chart (|Γ| > 1).");
            }
        }

        function placeTarget() {
            const R = parseFloat(targetRealImpedanceInput.value);
            const X = parseFloat(targetImagImpedanceInput.value);
            if (isNaN(R) || isNaN(X)) {
                alert("Please enter valid real and imaginary impedance values.");
                return;
            }
            const { x, y } = impedanceToGamma(R, X);
            const mag = Math.sqrt(x * x + y * y);
            if (mag <= 1) {
                smithChart.data.datasets[15].data = [{ x: x, y: y }];
                updateMatchingSolution();
                smithChart.update();
                console.log(`Target placed at: x=${x.toFixed(2)}, y=${y.toFixed(2)}, Z=${R.toFixed(1)}+j${X.toFixed(1)}`);
            } else {
                alert("Impedance results in a reflection coefficient outside the Smith Chart (|Γ| > 1).");
            }
        }

        function updateMatchingSolution() {
            const startData = smithChart.data.datasets[13].data[0];
            const targetData = smithChart.data.datasets[15].data[0];
            if (startData && targetData) {
                const startZ = calculateImpedance(startData.x, startData.y);
                const targetZ = calculateImpedance(targetData.x, targetData.y);
                const freqBase = parseFloat(frequencyValueInput.value);
                const unit = frequencyUnitSelect.value;
                const freqHz = freqBase * (unit === "Hz" ? 1 : unit === "kHz" ? 1e3 : unit === "MHz" ? 1e6 : 1e9);
                const { series, shunt } = calculateMatchingNetwork(startZ, targetZ, freqHz);
                matchingSolutionDiv.textContent = `Series: ${series}, Shunt: ${shunt}`;
                smithChart.data.datasets[16].data = generateMatchingPath(startData, targetData);
            } else {
                matchingSolutionDiv.textContent = "Place both markers for matching solution";
                smithChart.data.datasets[16].data = [];
            }
            smithChart.update();
        }

        function toggleReflectionCircles() {
            const show = showReflectionCirclesCheckbox.checked;
            smithChart.data.datasets[14].hidden = !show;
            smithChart.update();
        }

        function updateReflectionFromMagnitude() {
            const gamma = parseFloat(reflectionValueInput.value);
            if (isNaN(gamma) || gamma < 0 || gamma > 1) {
                alert("Please enter a reflection coefficient between 0 and 1.");
                reflectionValueInput.value = 0.5;
                returnLossValueInput.value = -6;
                reflectionSlider.value = 0.5;
            } else {
                const returnLoss = gammaToReturnLoss(gamma);
                returnLossValueInput.value = returnLoss.toFixed(1);
                reflectionSlider.value = gamma;
                smithChart.data.datasets[14].data = generateReflectionCircle(gamma);
                smithChart.update();
            }
        }

        function updateReflectionFromReturnLoss() {
            const returnLoss = parseFloat(returnLossValueInput.value);
            if (isNaN(returnLoss) || returnLoss > 0) {
                alert("Please enter a return loss less than or equal to 0 dB.");
                reflectionValueInput.value = 0.5;
                returnLossValueInput.value = -6;
                reflectionSlider.value = 0.5;
            } else {
                const gamma = returnLossToGamma(returnLoss);
                reflectionValueInput.value = gamma.toFixed(2);
                reflectionSlider.value = gamma;
                smithChart.data.datasets[14].data = generateReflectionCircle(gamma);
                smithChart.update();
            }
        }

        function updateReflectionFromSlider() {
            const gamma = parseFloat(reflectionSlider.value);
            reflectionValueInput.value = gamma.toFixed(2);
            returnLossValueInput.value = gammaToReturnLoss(gamma).toFixed(1);
            smithChart.data.datasets[14].data = generateReflectionCircle(gamma);
            smithChart.update();
        }

        function updateFrequencyFromInput() {
            const freq = parseFloat(frequencyValueInput.value);
            if (isNaN(freq) || freq < 1) {
                frequencyValueInput.value = 1;
            }
            const unit = frequencyUnitSelect.value;
            const freqHz = freq * (unit === "Hz" ? 1 : unit === "kHz" ? 1e3 : unit === "MHz" ? 1e6 : 1e9);
            const logFreq = Math.log10(freqHz);
            frequencySlider.value = (logFreq / 10) * 10; // Map 0-10 GHz to 0-10
            updateMatchingSolution();
        }

        function updateFrequencyFromUnit() {
            const freq = parseFloat(frequencyValueInput.value);
            const unit = frequencyUnitSelect.value;
            const freqHz = freq * (unit === "Hz" ? 1 : unit === "kHz" ? 1e3 : unit === "MHz" ? 1e6 : 1e9);
            const logFreq = Math.log10(freqHz);
            frequencySlider.value = (logFreq / 10) * 10;
            updateMatchingSolution();
        }

        function updateFrequencyFromSlider() {
            const sliderVal = parseFloat(frequencySlider.value);
            const freqHz = Math.pow(10, sliderVal); // 0-10 maps to 1Hz-10GHz
            const unit = frequencyUnitSelect.value;
            const freq = freqHz / (unit === "Hz" ? 1 : unit === "kHz" ? 1e3 : unit === "MHz" ? 1e6 : 1e9);
            frequencyValueInput.value = freq.toFixed(2);
            updateMatchingSolution();
        }

        // Mouse move handler
        smithChart.canvas.addEventListener('mousemove', (event) => {
            const rect = smithChart.canvas.getBoundingClientRect();
            const xPixel = event.x - rect.left;
            const yPixel = event.y - rect.top;
            const x = -1 + (2 * xPixel / rect.width);
            const y = 1 - (2 * yPixel / rect.height);
            const mag = Math.sqrt(x * x + y * y);
            if (mag <= 1) {
                const { impedance } = calculateImpedance(x, y);
                mouseImpedanceDiv.textContent = impedance;
                lastMouseX = x;
                lastMouseY = y;
            } else {
                mouseImpedanceDiv.textContent = "Outside chart";
                lastMouseX = null;
                lastMouseY = null;
            }
        });

        // Mouse wheel handlers
        reflectionValueInput.addEventListener('wheel', (event) => {
            event.preventDefault();
            const delta = event.deltaY > 0 ? -0.01 : 0.01;
            let gamma = parseFloat(reflectionValueInput.value) + delta;
            gamma = Math.max(0, Math.min(1, gamma));
            reflectionValueInput.value = gamma.toFixed(2);
            returnLossValueInput.value = gammaToReturnLoss(gamma).toFixed(1);
            reflectionSlider.value = gamma;
            smithChart.data.datasets[14].data = generateReflectionCircle(gamma);
            smithChart.update();
        });

        returnLossValueInput.addEventListener('wheel', (event) => {
            event.preventDefault();
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            let returnLoss = parseFloat(returnLossValueInput.value) + delta;
            returnLoss = Math.max(-100, Math.min(0, returnLoss));
            returnLossValueInput.value = returnLoss.toFixed(1);
            const gamma = returnLossToGamma(returnLoss);
            reflectionValueInput.value = gamma.toFixed(2);
            reflectionSlider.value = gamma;
            smithChart.data.datasets[14].data = generateReflectionCircle(gamma);
            smithChart.update();
        });

        // Load math.js
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js";
        script.onload = generateSmithChart;
        document.head.appendChild(script);
    </script>
</body>
</html>
